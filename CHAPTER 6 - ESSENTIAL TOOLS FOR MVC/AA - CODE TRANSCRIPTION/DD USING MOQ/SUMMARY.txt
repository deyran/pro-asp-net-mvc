DD USING MOQ -> 145
    "Mocking is a process used in unit testing when the unit being tested has external dependencies. The purpose of mocking is to isolate and focus on the code being tested and not on the behavior or state of external dependecies. In mocking, the dependecies are replaced by closely controlled replacemanets objects that simulate the behavior of the real ones. [...]"
    Font: https://www.telerik.com/products/mocking/unit-testing.aspx
    Date: 07-05-21

    The Moq object is useful for:
        1 - Class that depends on other classes to work
        2 - Simulate the functionality of real objects, but in a specific and controlled way 
        3 - Narrow the focus, so that you only examine the functionality in which you are interested

DDAA UNDERSTANDING THE PROBLEM -> 146
    The purpose of this section is:
        1. Demonstrate the problem to fix
        2. Use unit test using class LinqValueCalculator 
    
    >> Listing 6-31. The contents of the LinqValueCalculator.cs file -> 146

    >> Listing 6-32. Add a Unit Test for the ShoppingCart class in the UnitTest2.cs file -> 146
        1. Right-click on the "EssentialTools.Test"
        2. Add > Unit Test        

DDBB ADDING MOQ TO THE VISUAL STUDIO PROJECT -> 147

DDCC A MOCK OBJECT TO A UNIT TEST -> 147
    >> Listing 6-33. Using a Mock object in a Unit Test in the UnitTest2.cs file -> 147

    >> CREATING A MOCK OBJECT -> 148
        Creating the strongly typed Mock object
        ...
        Mock<IDiscountHelper> mock = new Mock<IDiscountHelper>();
        ...

    >> SELECTING A METHOD -> 149
        [...] Specify the way that it behaves [...]
        ...
        mock.Setup(m => m.ApplyDiscount(It.IsAny<decimal>())).Returns(total => total);
        ...

        The It class defines a number of methods that are used with generic type parameters. In this case, I have called the IsAny method using decimal as the generic type. This tells Moq to apply the behavior I am defining whenever I call ApplyDiscount method any decimal value.

    >> DEFINING THE RESULT -> 150
        ...
        ... .Returns(total => total);
        ...    
        By calling Returns method with decimal type parameter, I tell Moq that I am going to return a decimal value. For the lambda expression, Moq passes me a value of the type I receive in the ApplyDiscount method. I create a pass-through method in the example, in which I return the value that is passed to the mock ApplyDiscount method without performing any operations on it.

    >> USING THE MOCK OBJECT -> 150
        ...
        var target = new LinqValueCalculator(mock.Object);
        ...

        ...
        Assert.AreEqual(products.Sum(e => e.Price), result);
        ...

        The benefit of using Moq in this way is that my unit test only checks the behavior of the LinqValueCalculator object and does not depend on any of the real implementations of the IDiscountHelper interface in the Moldels folder. This means that when my tests fail, I know that the problem is either in the LinqValueCalculator implementation or in the way I set up mock object, and solving a problem from either of these sources is simpler and easier than dealing with a chain of real objects and the interactions between them.

DDDD CREATING A MORE COMPLEX MOCK OBJECT -> 150
    >> Listing 6-34. Mocking the behavior of the MinimumDiscountHelper class in the UnitTest2.cs file -> 151
        >>>> The order in which you call the Setup method affects the behavior of the mock object.
        >>>> Moq evaluates the behaviors in reverse order, so that it considers the most recent calls to the Setup method first.
        >>>> So you have to create your mocks behaviors in order from the most general to the most specific.

    >> MOCKING FOR SPECIFIC VALUES (AND THROWING AN EXCEPTION) -> 152
    >> MOCKING FOR A RANGE OF VALUES -> 153
-----------------------------------------------------------------------------------------------------------

DD USING MOQ -> 145
DDAA UNDERSTANDING THE PROBLEM -> 146